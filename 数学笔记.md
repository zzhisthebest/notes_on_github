1.原群（英语：Magma）是抽象代数领域中的一种基本代数结构。原群定义为一个集合和这个集合上满足封闭性的一种二元运算，即：对于集合 \(M\) 和 \(M\) 上的一个二元运算 \( \circ \)，若满足 \(M\) 中的任意两个元素经过 \( \circ \) 运算，得到的结果仍在 \(M\) 中，则称它们构成一个原群，记作 \( (M, \circ) \)。
2.偏序集是一种数学结构，表示集合中的元素按照某种方式是有序的，但不一定是完全有序的。换句话说，某些元素之间可能没有明确的顺序关系。
3.欧氏空间：
4.群的定义：

一个 **群** 是一个集合 \( G \) 和一个二元运算 \( * \)（通常是加法或乘法），满足以下四个条件：

1. **封闭性（Closure）**：
   对于 \( G \) 中的任意两个元素 \( a, b \in G \)，它们的运算结果 \( a * b \) 也必须属于 \( G \)。  
   换句话说，群中的元素在运算下是封闭的。
   \[
   \forall a, b \in G, \, a * b \in G
   \]

2. **结合性（Associativity）**：
   对于群中的任意三个元素 \( a, b, c \in G \)，必须满足运算是结合的，即：
   \[
   (a * b) * c = a * (b * c)
   \]
   这意味着你可以任意地选择括号位置，结果是一样的。

3. **单位元（Identity element）**：
   存在一个特别的元素 \( e \in G \)，称为**单位元**（或**恒等元素**），使得对于任意的元素 \( a \in G \)，都有：
   \[
   e * a = a * e = a
   \]
   换句话说，单位元在运算中不会改变其他元素。

4. **逆元（Inverse element）**：
   对于每个元素 \( a \in G \)，存在一个元素 \( b \in G \)，称为 \( a \) 的**逆元素**，使得：
   \[
   a * b = b * a = e
   \]
   其中 \( e \) 是单位元。换句话说，元素 \( a \) 的逆元 \( b \) 使得它们的运算结果为单位元。



5.加法群：群的二元运算是加法，显然这时单位元是0。

6.Lipschitz 连续

一个函数 \( f : X \to Y \) 被称为 **Lipschitz 连续**，如果存在一个常数 \( G \geq 0 \)，使得对于任意 \( x, y \in X \)，有：
\[
d_Y(f(x), f(y)) \leq G \cdot d_X(x, y)
\]

其中：

- \( d_X(x, y) \) 是定义域 \( X \) 中 \( x \) 和 \( y \) 之间的距离；
- \( d_Y(f(x), f(y)) \) 是值域 \( Y \) 中 \( f(x) \) 和 \( f(y) \) 之间的距离；
- \( G \) 是 **Lipschitz 常数**，用来控制函数 \( f \) 的增长。

---

几何意义：

- **Lipschitz 连续性表示函数 \( f \) 的增长率是受限制的**。输出的变化率不会超过输入的变化率的 \( G \) 倍。
- **直观上，Lipschitz 连续函数的图像“不会太陡峭”**。

7.次梯度集合（Subdifferential）

次梯度的所有可能值的集合被称为 **次梯度集合**（Subdifferential），记作 \( \partial f(x) \)：

\[
\partial f(x) = \{ g \in \mathbb{R}^n \mid f(y) \geq f(x) + \langle g, y - x \rangle, \, \forall y \in C \}
\]

- 如果 \( f \) 是可微的，次梯度集合只有一个元素，即梯度 \( \nabla f(x) \)：
  \[
  \partial f(x) = \{\nabla f(x)\}
  \]

- 如果 \( f \) 在 \( x \) 不可导，次梯度集合可能包含多个向量。


8. **次梯度法：优化不可微凸函数的算法**

#### **优化问题**

次梯度法解决以下优化问题：

\[
\min_{x \in \mathbb{R}^n} f(x)
\]

其中：
- \( f(x) \) 是一个 **凸函数**；
- \( f(x) \) 可能不可微，但其 **次梯度集合** \( \partial f(x) \) 非空。

---

#### **算法描述**

**迭代规则**：

1. **初始化**：
   - 选择初始点 \( x_0 \)；
   - 选择步长序列 \( \{\alpha_k\}_{k=0}^\infty \)，并满足特定条件。

2. **迭代更新**：
   在每次迭代 \( k \) 时，执行以下更新：
   \[
   x_{k+1} = x_k - \alpha_k \cdot g_k
   \]
   其中：
   - \( g_k \in \partial f(x_k) \)，是 \( f(x) \) 在 \( x_k \) 处的次梯度；
   - \( \alpha_k > 0 \) 是步长，控制更新幅度。

3. **停止条件**：
   - 当 \( \|g_k\| \) 非常接近 0 时，停止；
   - 或者达到最大迭代次数。

---

#### **收敛性**

次梯度法针对凸函数 \( f(x) \) 是收敛的。步长序列 \( \{\alpha_k\} \) 满足以下条件时，可保证算法收敛：

1. \(\sum_{k=0}^\infty \alpha_k = \infty\)：步长序列的总和发散，确保算法能继续探索。
2. \(\sum_{k=0}^\infty \alpha_k^2 < \infty\)：步长平方和收敛，确保步长逐渐减小，避免发散。

证明：略，看明白了，没什么用。
**示例步长**：
\[
\alpha_k = \frac{1}{\sqrt{k+1}}
\]
该步长序列满足上述收敛条件。

---

#### **理论保证**

在满足步长条件的前提下，次梯度法可以找到凸函数的全局最优解。虽然次梯度法的收敛速率较慢（通常为 \( O(1/\sqrt{k}) \)），但它对不可微的凸函数具有很好的鲁棒性。

---

#### **总结**

次梯度法是一种专门针对不可微凸函数的优化算法，通过次梯度 \( g_k \) 和步长 \( \alpha_k \) 的更新规则逐步逼近目标函数的最优解。该方法具有简单、稳定的特点，适用于广泛的凸优化问题场景。

9.